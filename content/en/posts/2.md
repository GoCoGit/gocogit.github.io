+++
date = '2024-02-05T23:17:30+08:00'
draft = false
title = 'Go Pointer resolution'
+++

`var a *int`

这行代码是啥意思？声明一个叫a的变量，它是`*int`类型。

`*int` 是类型，表示变量里存的是地址；`a`是变量，类型是`*int`，值是地址。

```go
var a *int
fmt.Println(reflect.TypeOf(a)) // *int
```

上述代码，打印a的类型，可见a的类型就是`*int`

此时，a本身的值是什么呢？

```go
var a *int
var b int
fmt.Println(a) // nil
fmt.Println(b) // 0
```

在Go中，所有变量在声明但未显式初始化时，都会被自动赋予一个类型对应的零值 [链接](https://go.dev/tour/basics/12)

不同类型的零值不同：

+ 数值类型（如 int, float64） → 0
+ 布尔类型 → false
+ 字符串类型 → ""
+ 指针、切片、map、接口、channel、函数 → nil

由于a的类型是`指向int的指针类型`，而我们并没有给a赋值（赋地址值），因此a的值就是nil



符号&的意思是对变量取地址，那么此时`&a`的值是什么呢？

```go
var a *int
fmt.Println(&a) // 0xc00008e058
```

虽然此时a的值是nil，但a这个变量在栈上已经被分配了地址，打印的是内存地址

那么`*a`的值是什么？在表达式中，`*`用于解引用，即沿着指针去访问它指向的那个值。因为指针本身只是一个存地址的变量，这个地址指向的地方才是真正的值。

```go
var a *int
fmt.Println(*a) // panic: runtime error: invalid memory address or nil pointer dereference
```

报了空指针错误，因为此时a的值是nil，正常来说他应该会存储一个int值的地址，解引用后就能根据这个地址拿到实际的int值，但此时地址就是nil，也就是没有指向任何实际地址，Go的运行时检查到你在访问一个无效地址，于是触发panic。

如何给*a赋值

```go
var a *int
a = new(int) // 在内存里分配一块能存放int的空间并返回这块空间的地址，此时*a = 0，即int的默认零值
*a = 10 // 给a指向的int值赋值10
fmt.Println(a) // 0xc00008c0a8 上面这块int空间的地址
fmt.Println(&a) // 0xc00008e058 变量a在栈上的地址
fmt.Println(*a) // a的值，此时是10
```

必须要先用new分配空间吗？

```go
var a *int
*a = 10
fmt.Println(*a) // panic: runtime error: invalid memory address or nil pointer dereference
```

上面这段代码，报错的原因是一样的，即没有给a赋值，a仍然是nil，没有指向任何实际地址，*a = 10还是在尝试访问一个无效地址，报错。


tips：在解引用指针前一定要保证它非nil，可以使用`if a != nil`来防止 panic



go的结构体相较于c语言，可以声明方法。方法能给用户自定义的类型（结构体）添加新的行为。它和函数的区别在于方法有一个接收者，给一个函数添加一个接收者，那么它就变成了方法。接收者可以是值接收者，也可以是指针接收者。

```go
type Conn struct {
	Uid string
}

type Server struct {
	Id string
	*Conn
}

func (s *Server) AddConn(conn *Conn) {
	s.Conn = conn
	fmt.Println(conn.Uid)
}

func (s Server) UpdateId() {
	s.Id = "2"
}

func (s Server) UpdateConn() {
	s.Conn.Uid = "B"
}

func main() {
	s := &Server{Id: "1"}
	s.AddConn(&Conn{Uid: "A"})

	fmt.Println(s.Id)
	s.UpdateId()
	fmt.Println(s.Id)

	fmt.Println(s.Conn.Uid)
	s.UpdateConn()
	fmt.Println(s.Conn.Uid)
}
```

上面这段代码，`func (s *Server)`就是指针接收者，`s`是`*Server`类型，即指向`Server`实例的指针，方法里对`s`的修改会直接作用到原来的`Server`实例。

如果是`func (s Server)`，`s`就是`Server`的副本，方法里对`s`的修改不会影响原来的结构体。



先来看`AddConn`方法，其参数声明`conn`是指针类型，指向一个`Conn`实例，也就是`conn`的值是一个地址。

那为什么可以直接通过`conn.Uid`来访问属性值？Go为指针访问结构体字段提供了语法糖，此时的`conn.Uid`被编译器翻译为`(*conn).Uid`，相当于自动帮你做了解引用。



程序运行结果：

```go
A // AddConn打印的conn.Uid，初始值A
1 // 27行打印的s.Id，初始值1
1 // 29行打印的s.Id，可见虽然执行过UpdateId，但由于是值接收者，修改的只是s的拷贝，并没有对s本身做修改
A // 31行打印的s.Conn.Uid，初始值A
B // 33行打印的s.Conn.Uid，虽然UpdateConn也是值接收者，但不论是拷贝还是本体，都指向同一个Conn实例，因此做的修改会被保存
```



再看一个例子：

```go
type coder interface {
	code()
	debug()
}

type Gopher struct {
	language string
}

func (p Gopher) code() {
	fmt.Printf("I am coding %s language\n", p.language)
}

func (p *Gopher) debug() {
	fmt.Printf("I am debuging %s language\n", p.language)
	p.language = "Java"
}

func main() {
	var c coder = &Gopher{"Go"}
	c.debug()
	c.code()
}
```

`var c coder`这里声明了接口变量c，它的类型是coder，因此赋值给c的东西必须实现接口coder的方法。

+ `&Gopher{"Go"}`是新实例的地址，其类型是`*Gopher`：指向Gopher的指针类型。
+ `Gopher{"Go"}`是一个新实例，其类型就是`Gopher`，是值类型。

指针类型的**方法集**包含指针接收者 + 值接收者方法，而值类型的**方法集**只包含值接收者方法。[Go Wiki: MethodSets](https://go.dev/wiki/MethodSets#the-spec)  
这里的“自动包含”其实是 Go 的方法集定义和自动解引用机制，并不是生成了新的方法。  

所以，如果`var c coder = Gopher{"Go"}`，编译器就会报错`Gopher does not implement coder (method debug has pointer receiver)` —— 值类型不包含指针接收者方法，此时的Gopher实例无法实现coder的`debug`方法，因此该实例不是coder类型的，无法给c赋值。