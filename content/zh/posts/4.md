+++
date = '2025-10-17T05:17:45+08:00'
draft = false
title = 'Go函数式选项模式'
+++

通过一个例子来讲解

```go
type Server struct {
  host string
  port int
}

func New(host string, port int) *Server {
  return &Server{host, port}
}

func (s *Server) Start() error {
}
```

这里定义了一个Server结构体，在使用时，会调用其构造函数传递参数进去，来初始化Server对象：

```go
func main() {
  svr := New("localhost", 1234)
  if err := svr.Start(); err != nil {
    log.Fatal(err)
  }
}
```

在Java等其他面向对象语言中，可以通过函数重载，定义多个同名但不同参数的构造函数，来传递不同的参数实例化Server对象。但Go中没有函数重载，因此我们只能是定义多个不同名的构造函数：

```go
type Server struct {
  host string
  port int
  // 增加了两个属性
  timeout time.Duration
  maxConn int
}

func New(host string, port int) *Server {
  return &Server{host, port, time.Minute, 100} // 新增属性赋默认值
}

// 提供两个额外的构造函数
func NewWithTimeout(host string, port int, timeout time.Duration) *Server {
  return &Server{host, port, timeout}
}

func NewWithTimeoutAndMaxConn(host string, port int, timeout time.Duration, maxConn int) *Server {
  return &Server{host, port, timeout, maxConn}
}
```

这种方式适用于配置项较少，且基本不变化的情况，如果配置项需要不断增减，则需要根据配置项对应地修改构造函数，改动较多。



更好的解决方案是使用函数式选项模式（Functional Option Pattern）

在这个模式中，首先需要定义一个Option函数类型：

```go
type ServerOption func(opt *Server)
```

ServerOption类型是一个函数类型，接收*Server类型的参数，同时需要定义一系列返回ServerOption的函数：

```go
func WithServerHost(host string) ServerOption {
	return func(opt *Server) {
		opt.Host = host
	}
}

func WithServerPort(port string) ServerOption {
	return func(opt *Server) {
		opt.Port = port
	}
}
```

WithXXX的函数，返回值是一个ServerOption类型的匿名函数，该匿名函数接收Server类型的参数，修改其属性值。

**注意，匿名函数里，给参数所赋的值，来源于WithXXX的参数，在这个闭包里，匿名函数会记住WithXXX函数所传入的参数值。**

例如，调用`WithServerHost("127.0.0.1")`时，其返回的匿名函数就等价于：

```go
func(opt *Server) {
    opt.Host = "127.0.0.1"  // 这个127.0.0.1是固定的，不会改变
}
```



之后定义Server的构造函数，Server的构造函数需要接收ServerOption类型的不定参数：

```go
func NewServer(opts ...ServerOption) Server {
    // opts是一堆ServerOption类型的函数

    // 这里定义参数的默认值
    o := Server{
        Host: "127.0.0.1",
        Port: "8080",
    }

    // 遍历每个函数，执行，将上面定义的默认对象作为参数传递进去
    // 下面执行的opt函数就是形如：
    // func(opt *Server) {
    //   opt.XX = XX  
    // }
    // 的函数，在函数内覆盖o的默认值
    for _, opt := range opts {
        opt(&o)
    }

    return o
}
```

使用方法：

```go
o := NewServer(
    WithServerHost("127.0.0.1"), 
    WithServerPort("8080")
)
```

这样设计，将来需要增加配置项时，只需要增加对应的WithXXX函数和在构造函数里给这个新增的配置项赋默认值即可，不需要排列组合增加新的构造函数。